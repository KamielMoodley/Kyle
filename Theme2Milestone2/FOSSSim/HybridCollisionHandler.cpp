#include "HybridCollisionHandler.h"
#include "ContinuousTimeUtilities.h"
#include <iostream>
#include <set>
#include <algorithm>
#include "HybridCollisionComparison.h"

HybridCollisionHandler::HybridCollisionHandler(int maxiters, double COR) : ContinuousTimeCollisionHandler(COR), m_maxiters(maxiters)
{

}

HybridCollisionHandler::~HybridCollisionHandler()
{

}

void syncScene();

// Applies hybrid collision response to the simulation.
// For up to m_maxiters iterations:
//  - Find all pairs of colliding primitives using continuous-time collision detection
//  - Simultaneously apply an impulse for each detected collision
// After m_maxiters iterations, resolves remaining collisions using the failsafe, as described in the assignment instructions
//
// Does not need to be modified by students
void HybridCollisionHandler::handleCollisions(TwoDScene &scene, const VectorXs &oldpos, VectorXs &oldvel, scalar dt)
{
    VectorXs xend(oldpos.size());
    VectorXs vend(oldvel.size());

    xend = scene.getX();
    vend = scene.getV();

    bool done = applyIterativeImpulses(scene, oldpos, scene.getX(), scene.getV(), dt, xend, vend);

    scene.getX() = xend;
    scene.getV() = vend;

    syncScene();

    if(!done)
        applyGeometricCollisionHandling(scene, oldpos, xend, vend, dt, scene.getX(), scene.getV());
}

// Takes start of time step and end of time step positions, and performs continuous-time collision detection.
// Inputs:
//   scene:   The simulation scene, needed for radii, etc.
//   qs:      Start of time step positions.
//   qe:      End of time step positions.
// Output:
//   Returns a list of all collisions found after performing continuous-time collision detection using positions qs and qe.
std::vector<CollisionInfo> HybridCollisionHandler::detectCollisions(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe)
{
    Vector2s n;
    double time;
    std::vector<CollisionInfo> result;
    for (int i = 0; i < scene.getNumParticles(); i++)
    {
        for (int j = i + 1; j < scene.getNumParticles(); j++)
        {
            if (detectParticleParticle(scene, qs, qe, i, j, n, time))
            {
                result.push_back(CollisionInfo(CollisionInfo::PP, i, j, n, time));
                std::cout << i << '-' << j << std::endl;
            }
        }

        for (int e = 0; e < scene.getNumEdges(); e++)
        {
            if (scene.getEdges()[e].first != i && scene.getEdges()[e].second != i)
                if (detectParticleEdge(scene, qs, qe, i, e, n, time))
                {
                    result.push_back(CollisionInfo(CollisionInfo::PE, i, e, n, time));
                }
        }

        for (int f = 0; f < scene.getNumHalfplanes(); f++)
        {
            if (detectParticleHalfplane(scene, qs, qe, i, f, n, time))
            {
                result.push_back(CollisionInfo(CollisionInfo::PH, i, f, n, time));
            }
        }
    }
    return result;
}

// Takes a list of detected collisions, positions at the start of time step, and predicted end of time step positions and velocities, and updates the
// predicted quantities by applying impulses.
// Inputs:
//   scene:      The simulation scene, needed for radii, masses, etc.
//   collisions: The list, generated by detectCollisions, of collisions that need to be responded to.
//   qs:         Start of time step positions.
//   qe:         Predicted end of time step positions.
//   qdote:      Predicted enf of time step velocities.
//   dt          The time step length
// Outputs:
//   qm:         Predicted end of time step positions after impulses have been applied. Do *NOT* pass in the same vector as for qe!
//   qdotm:      Predicted end of time step velocities after impulses have been applied.
void HybridCollisionHandler::applyImpulses(const TwoDScene &scene, const std::vector<CollisionInfo> &collisions, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qm, VectorXs &qdotm)
{
    qm = qe;
    qdotm = qdote;
    for (int i = 0; i < (int)collisions.size(); i++)
    {
        switch (collisions[i].m_type)
        {
            case CollisionInfo::PP:
            {
                respondParticleParticle(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
            case CollisionInfo::PE:
            {
                respondParticleEdge(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
            case CollisionInfo::PH:
            {
                respondParticleHalfplane(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
        }
    }
}



std::string HybridCollisionHandler::getName() const
{
    return "Hybrid Collision Handling";
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////        Impact Zone Utilities
////
////        You can use them (but please do make sure you understand what they do), or
////        implement your own versions of whatever you need
////
////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

bool intersects(const ImpactZone &z1, const ImpactZone &z2)
{
    std::set<int> temp;
    set_intersection(z1.m_verts.begin(), z1.m_verts.end(), z2.m_verts.begin(), z2.m_verts.end(), inserter(temp, temp.end()));
    return temp.size() > 0;
}

ImpactZone mergeZones(const ImpactZone &z1, const ImpactZone &z2)
{
    std::set<int> combinedverts;
    set_union(z1.m_verts.begin(), z1.m_verts.end(), z2.m_verts.begin(), z2.m_verts.end(), inserter(combinedverts, combinedverts.end()));
    return ImpactZone(combinedverts, z1.m_halfplane || z2.m_halfplane);
}


void mergeAllZones(ImpactZones &zones)
{
    ImpactZones result;

    ImpactZones *src = &zones;
    ImpactZones *dst = &result;
    do
    {
        dst->clear();
        for(int i=0; i<(int)src->size(); i++)
        {
            bool merged = false;
            for(int j=0; j<(int)dst->size(); j++)
            {
                if(intersects((*dst)[j], (*src)[i]))
                {
                    ImpactZone newzone = mergeZones((*dst)[j], (*src)[i]);
                    (*dst)[j] = newzone;
                    merged = true;

                    break;
                }
            }
            if(!merged)
            {
                dst->push_back((*src)[i]);
            }
        }
        std::swap(src, dst);
    }
    while(src->size() < dst->size());

    zones = *dst; // copy
}

void growImpactZones(const TwoDScene &scene, ImpactZones &zones, const std::vector<CollisionInfo> &impulses)
{
    for(int i=0; i<(int)impulses.size(); i++)
    {
        switch(impulses[i].m_type)
        {
            case CollisionInfo::PP:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                verts.insert(impulses[i].m_idx2);
                zones.push_back(ImpactZone(verts, false));
                break;
            }
            case CollisionInfo::PE:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                verts.insert(scene.getEdge(impulses[i].m_idx2).first);
                verts.insert(scene.getEdge(impulses[i].m_idx2).second);
                zones.push_back(ImpactZone(verts, false));
                break;
            }
            case CollisionInfo::PH:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                zones.push_back(ImpactZone(verts, true));
                break;
            }
        }
    }
    mergeAllZones(zones);
}

// todo: needs improvement
bool zonesEqual(const ImpactZones &zones1, const ImpactZones &zones2)
{
    if(zones1.size() != zones2.size())
        return false;

    for(int i=0; i<(int)zones1.size(); i++)
    {
        bool found = false;
        for(int j=0; j<(int)zones2.size(); j++)
        {
            if(zones1[i] == zones2[j])
            {
                found = true;

                break;
            }
        }
        if(!found)
            return false;
    }
    return true;
}





////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////        Student Code
////
////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////



// Iteratively performs collision detection and interative impulse response until either there are no more detected collisions, or the maximum number of
// iterations has been reached. See the assignment instructions for more details.
// The maximum number of iterations is stored in the member variable m_maxiters.
// Inputs:
//   scene:   The simulation scene. Get masses, radii, edge endpoint indices, etc. from here. Do *NOT* get any positions or velocities from here.
//   qs:      The positions of the particles at the start of the time step.
//   qe:      The predicted end-of-time-step positions.
//   qdote:   The predicted end-of-time-step velocities.
//   dt:      The time step size.
// Outputs:
//   qefinal:    The collision-free end-of-time-step positions (if no new collisions are detected), or the last set of predicted end-of-time-step positions
//               (if maximum number of iterations reached).
//   qdotefinal: Same as qefinal, but for velocities.
//   Returns true if the algorithm found a collision-free state. Returns false if the maximum number of iterations was reached without finding a collision-
//   free state.
// Possibly useful functions: detectCollisions, applyImpulses.
bool HybridCollisionHandler::applyIterativeImpulses(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qefinal, VectorXs &qdotefinal)
{
    // Add Theme 2 Milestone 2 code here.

    // 1. Step the positions qs and velocities forward using the numerical integrator to get initial predicted end-of-time-step positions qe (qe0) and velocities qdote (qdote0)

    std::vector<CollisionInfo> collisionResult;
    VectorXs &qm = qefinal;
    VectorXs &qdotm = qdotefinal;
    VectorXs qei, qdotei;

    // 2. Assume the particles move with constant velocity from qs to qe0, and *perform continuous-time collision detection* with q(t) = qs + t∆q0, where ∆q0 = qe0 − qs.
    collisionResult = detectCollisions(scene, qs, qe);

    qm = qe; qdotm = qdote; // applyImpulses(scene, collisionResult, qs, qe, qdote, dt, qm, qdotm)

    for (int i = 0; i < m_maxiters; ++i) {
        if (collisionResult.empty()) return true; // collision free
        else {
            std::cout << i << ',';
            qei = qm; qdotei = qdotm;
            // a. Apply impulses to the predicted velocities qdotei to get new predicted velocities qdotm (qdote(i+1))
            // b. Modify positions to get new predicted positions qm (qe(i+1))
            applyImpulses(scene, collisionResult, qs, qei, qdotei, dt, qm, qdotm); // qei -> qe(i+1): qm -> qm
            // c. perform continuous-time collision detection
            collisionResult = detectCollisions(scene, qs, qm);
        }
    }
    return false;
}


// Resolves any remaining collisions in a simulation time step by setting the velocities of all particles involved in a way that guarantees
// that the distance between particles in an impact zone does not change.
// Inputs:
//   scene:   The simulation scene, from which the masses of the particles, current (colliding) positions, and whether or not a given particle is fixed,
//             can be retrieved.
//   qs:      The positions of the particles at the start of the time step.
//   qe:      The predicted end-of-timestep positions of the particles.
//   qdote:   The precicted end-of-timestep velocities of the particles.
//   zone:    Information about the impact zone of colliding particles. zone.m_verts is an std::set of particle indices; each particle in this set
//            is part of the impact zone and needs to have its position and velocity changed. Whether or not a half-plane is part of the impact zone
//            can be checked by looking at zone.m_halfplane.
//   dt:      The time step.
// Outputs:
//   qe:      The end-of-timestep position of the particles, assuming rigid motion as in writeup section 4.5
//   qdote:   The end-of-timestep velocity of the particles, assuming rigid motion as in writeup section 4.5
inline Vector2s getRotateVec(const Vector2s& x) {
    return Vector2s(-x(1),x(0));
}
inline scalar calcMomentumOfInertia(const std::set<int> &ids, const VectorXs& m, const VectorXs& x, const Vector2s& xcm) {
    scalar I = 0;
    std::set<int>::const_iterator it;
    for(it = ids.begin(); it != ids.end(); ++it) {
        const int &i = *it;
        I += m(2*i) * (x.segment<2>(2*i) - xcm).squaredNorm();
    }
    return I;
}
inline scalar crossproduct(const Vector2s& x, const Vector2s& y) {
    return x(0)*y(1) - x(1)*y(0);
}
inline scalar calcAngularMomentum(const std::set<int> &ids, const VectorXs& m, const VectorXs& x, const Vector2s& xcm, const VectorXs& dx, const Vector2s& dxcm) {
    scalar L = 0; // two-dimensional cross-product ad - bc
    std::set<int>::const_iterator it;
    for(it = ids.begin(); it != ids.end(); ++it) {
        const int &i = *it;
        L += m(2*i) * crossproduct(x.segment<2>(2*i) - xcm, dx.segment<2>(2*i) - dxcm);
    }
    return L;
}
inline void getCenterOfMass(const std::set<int> &ids, const VectorXs& x, const VectorXs& m, Vector2s& xcm) {
    xcm.setZero();
    scalar msum = 0;
    std::set<int>::const_iterator it;
    for(it = ids.begin(); it != ids.end(); ++it) {
        const int &i = *it;
        msum += m(2*i);
        xcm += m(2*i) * x.segment<2>(2*i);
    }
    xcm /= msum;
}
void HybridCollisionHandler::performFailsafe(const TwoDScene &scene, const VectorXs &qs, const ImpactZone &zone, double dt, VectorXs &qe, VectorXs &qdote)
{
    // Add Theme 2 Milestone 2 code here.
    // rigidly moves each impact zone, guaranteeing a collision free end of step configuration

    const std::set<int> &ids = zone.m_verts;
    const VectorXs& m = scene.getM();
    VectorXs &qm = qe, dx; // set size ????????????
    Vector2s qcms, qcme, dxcm;

    // 1. Treat the particles as if they were part of a rigid body;
    // We do so by calculating ∆xcm and ωcm.
    dx = qe - qs;
    getCenterOfMass(ids, dx, m, dxcm);
    getCenterOfMass(ids, qs, m, qcms);
    scalar omegacm = calcAngularMomentum(ids, m, qs, qcms, dx, dxcm) /
            calcMomentumOfInertia(ids, m, qs, qcms); // L/I
    // 2. Step the rigid body forward in time to the end of the time step.
    qcme = qcms + dxcm;

    std::set<int>::const_iterator it;
    for(it = ids.begin(); it != ids.end(); ++it) {
        const int &i = *it;
        // Don't forget to handle fixed objects properly as in writeup section 4.5.1
        if (scene.isFixed(i)) {
            qm.segment<2>(2*i) = qs.segment<2>(2*i);
            qdote.segment<2>(2*i).setZero();
            continue;
        }

        // 3. Set each particle’s modified end-of-time-step position qm to the position dictated
        //      by the motion of the rigid body.
        qm.segment<2>(2*i) = qcme + std::cos(omegacm) * (qs.segment<2>(2*i) - qcms) + std::sin(omegacm) * getRotateVec(qs.segment<2>(2*i) - qcms);
        // 4. Also set the particle’s modified end-of-time-step velocity to (qm − qs) / h, where
        //      h is the length of the time step.
        qdote.segment<2>(2*i) = (qm.segment<2>(2*i) - qs.segment<2>(2*i))/dt;
    }



}


// Performs iterative geometric collision response until collision-free end-of-time-step positions and velocities are found. See the assignment
// instructions for details.
// Inputs:
//   scene:   The simulation scene. Get masses, radii, etc. from here. Do *NOT* get any positions or velocities from here.
//   qs:      The start-of-time-step positions.
//   qe:      The predicted end-of-time-step positions.
//   qdote:   The predicted end-of-time-step velocities.
//   dt:      The time step size.
// Outputs:
//   qm:    The final, collision-free end-of-time-step positions. (qm in the assignment instructions.)
//   qdotm: Same as qm, but for velocities.
// Possibly useful functions: detectCollisions, performFailsafe. You may find it helpful to write other helper functions for manipulating (merging,
// growing, etc) impact zones.
inline void HybridCollisionHandler::initializeImpactZone(const TwoDScene &scene, const std::vector<CollisionInfo> &collisionResult, ImpactZones &Z) {
    // (1) create an impact zone for each detected collisions.
    int verts[3];
    std::vector<CollisionInfo>::const_iterator it;
    for (it=collisionResult.begin(); it != collisionResult.end(); ++it) {
        const CollisionInfo &collision = *it;
        switch (collision.m_type) {
            case CollisionInfo::PP:
                verts[0] = collision.m_idx1; verts[1] = collision.m_idx2;
                Z.push_back(ImpactZone(std::set<int>(verts, verts+2), false));
                break;
            case CollisionInfo::PE:
                verts[0] = collision.m_idx1;
                verts[1] = scene.getEdge(collision.m_idx2).first;
                verts[2] = scene.getEdge(collision.m_idx2).second;
                Z.push_back(ImpactZone(std::set<int>(verts, verts+3), false));
                break;
            case CollisionInfo::PH:
                verts[0] = collision.m_idx1;
                Z.push_back(ImpactZone(std::set<int>(verts, verts+1), true));
                break;
        }
    }

    // (2) If any two impact zones Z1 and Z2 share a particle, they must be merged.
    // (3) Repeat until all zones are disjoint.
    mergeAllZones(Z); // &Z
}
void HybridCollisionHandler::applyGeometricCollisionHandling(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qm, VectorXs &qdotm)
{
    ImpactZones Z;
    ImpactZones Zprime;

    // Add Theme 2 Milestone 2 code here.
    // iteratively executes continuous time collision detection, gathers the collisions into a collection of impact zones

    // What you need to implement here: (same as writeup section 4.6)

    // 1. Perform continuous-time collision detection using positions qs and qe.
    std::vector<CollisionInfo> collisionResult = detectCollisions(scene, qs, qe);
    // 2. Initialize qm = qe and qdotm = qdote.
    qm = qe; qdotm = qdote;

    // 3. Construct a list of disjoint impact zones Z from the detected collisions.
    initializeImpactZone(scene, collisionResult, Zprime); // Z

    do {
        // 9. Set Z=Z' and goto step4.
        Z = Zprime;

        // 4. For each impact zone in Z, apply geometric collision response (by calling
        //      HybrdiCollisionHandler::performFailsafe), using positions qs and qm, and
        //      modifying qm and qdotm for the vertices in those zones.
        for (int i = 0; i < Z.size(); ++i) {
            performFailsafe(scene, qs, Z[i], dt, qm, qdotm);
        }

        // 5. Perform continuous-time collision detection using positions qs and qm.
        collisionResult = detectCollisions(scene, qs, qm);

        // 6. Construct a new list of impact zones Z′ consisting of all impact zones in Z,
        //      plus one zone for each detected collision.
        // 7. Merge the zones in Z' to get disjoint impact zones.
        Zprime = Z;
        initializeImpactZone(scene, collisionResult, Zprime);
    } while (!zonesEqual(Z, Zprime));
    // 8. If Z and Z' are equal, the algorithm is done, and qm and qdotm are the new,
    //      collision-free end-of-time-step positions.

}
